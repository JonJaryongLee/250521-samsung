## 찰떡! 검색어 교정 서비스  

**page4**  
어떤 검색엔진에서 키워드를 검색하면, 원하는 키워드를 유추하여 교정하는 서비스  


화면을 보시면 제밋는 ㅕ여화  
라고 오타가 있는데요, 해당 키워드는 오타이기 때문에 100프로 일치하는 검색어가 있을 수 없습니다.  

따라서, 현재 저장된 검색어 중 유사한 검색어로 "유추" 해서, 가장 유사한 검색어를 리턴하는것이 그 목적입니다.  


**page5**  
유추될 수 있는 검색어는 최대한 비슷한 검색어들이겠죠.  
대표적으로, 다음과 같은 예시들이 있습니다.  
1. 재밌는 영어  
2. 재밌는 영유  
3. 재밌는 영화  
4. 재밌는 형아  


과거의 검색엔진은, 이 중에서 단순히 가장 키워드 유사도가 높은 것을 선택하였습니다. 즉, 제시된 문자열 중, 문자열로서 유사도가 높은 키워드를 선택했었습니다.  

하지만 최신 검색엔진은 유사도가 높은 키워드들 중에, 가장 인기가 좋은 키워드를 선택합니다.  

이것이 우리가 구현할 찰떡 서비스입니다.  


**page6**  
찰떡 검색어 교정 서비스는 이를 위해, 최근에 사람들이 가장 검색을 많이 했던 키워드를 우선적으로 추천합니다.  

예를 들면, "제밌는 영아" 로 검색 시, "재밌는 영화" 를 사람들이 가장 많이 검색했다면, 설령 "재밌는 영어" 라는 문자열이 유사도가 높다 할지라도, 인기 순위에 의해 "재밌는 영화" 를 선택하게 됩니다.  


**page7**  
여기서 추가로, 요일별 검색량에 따라 인기 순위도 달라집니다.  
만약 월요일 1등 키워드가 "재밌는 영어" 라면, 월요일엔 "재밌는 영아" 의 결과는 "영어" 가 되겠지만, 일요일 1등 키워드가 "재밌는 영화" 일 경우, 결과는 "영화" 가 되는 것입니다.  


**page8**  
입력이 주어질 때는 상황이 총 세 가지로 나뉩니다.  
1. 완벽 HIT  
  : 해당 키워드가 자주 사용되는 키워드와 정확히 일치할 경우입니다. 이 경우엔 원문을 그대로 반환하면 됩니다. 만약 "한국 신화" 라는 키워드가 이미 존재하고, 정확하게 해당 키워드를 입력했을 경우엔 완벽 HIT 에 해당합니다. 물론, 이 경우 "한국 신화" 는 인기가 올라갔기 때문에 가산점을 주어야겠죠? 해당 부분에 대해선 다음 장에서 알아보겠습니다.  
2. 찰떡 HIT  
  : 찰떡 키워드들이 존재할 경우, 가장 점수가 높은 키워드를 반환합니다. "남유럽 신화" 라는 키워드가 현재 찰떡 키워드에 존재하진 않지만, 저장된 찰떡 키워드 중 "북유럽 신화" 의 점수가 가장 높을 경우, 해당 키워드를 반환합니다.  
3. 완벽 HIT 도 아니고 찰떡 HIT 도 아닐 경우, 입력 받은 키워드를 그대로 반환합니다.  
   : "동유럽신화" 는 완벽 HIT 도 아니고, 찰떡 HIT 도 아닌 경우에 해당하므로, 그대로 반환된 경우입니다.  


**page9**  
교정기 알고리즘 작동 방식입니다.  
1. 키워드가 지속적으로 입력이 주어집니다. 현재 저희 프로그램엔 500개의 키워드가 "요일" "키워드" 순으로 입력됩니다.  
2. 각 요일별로 최대 10개의 키워드를 관리하게 됩니다. 월요일 10개, 화요일 10개, 일요일까지 10개입니다.  

새로운 키워드엔 기본 점수가 부여됩니다. 다음장에서 살펴보겠지만 이것을 UZ 점수라고 할 것이구요, 10점부터 시작합니다.  
만약 최초로 월요일에 "재밌는 영화" 라는 키워드가 입력되었다면, 기본 점수 10점인 "재밌는 영화" 가 저장되는 것이죠.  
그런데, 월요일에 10개의 키워드가 이미 채워져있는 상태일수도 있습니다. 이 경우, 최저 점수를 가진 키워드와 비교하여 새로운 키워드로 대체될수도 있습니다.  


1. 완벽 HIT - 이것은 키워드가 기존 키워드와 완벽하게 일치하는 경우였죠. 이 경우, 해당 키워드의 점수가 증가합니다.  
2. 찰떡 HIT - 만약 100% 일치하는 키워드가 존재하지 않을 경우, 찰떡 알고리즘이 실행됩니다. 이 경우 어떻게 한다고 했죠? 가장 점수가 높은 키워드를 반환한다고 했습니다.  
   - 관리되는 10개의 키워드 중, 점수가 가장 높은것부터 검색합니다. 벡터가 항상 정렬된 형태로 유지되기에, loop 를 사용할 것입니다.  
   - 유사도 검사 알고리즘, 저희 프로그램에선 레벤슈타인이라는 알고리즘을 사용하는데요, 측정 결과 80% 이상 동일한 키워드가 발견되면 찰떡 키워드로 확정됩니다.  
3. 완벽 HIT 도 아니고 찰떡 HIT 도 아닐 경우, 입력받은 키워드를 그대로 반환한다고 했습니다. 요일에 해당하는 관리 목록에 추가될수도 있지만, 이것은 요일에 해당하는 키워드가 10개 이하일때 상황이구요, 이미 10개의 키워드가 존재하는 경우엔 기존 벡터에서 가장 점수가 낮은 키워드를 새로운 키워드로 대체하거나, 또는 대체되지 않을 수도 있습니다.  


**page10**  
세부 규칙입니다.  
1. 새로운 키워드엔 UZ 점수가 부여됩니다.  
   - 맨 처음 UZ 점수는 10점으로 시작하며, 새로운 키워드가 등장하면 1점씩 증가됩니다.  
   - 첫번째 키워드는 10점, 두번째 등장하는 키워드는 11점 식으로 계속 올라갑니다.  
2. 완벽 HIT 되었을 때 키워드 점수는 10% 증가하지만, 찰떡 HIT 는 점수가 증가하지 않습니다.  
3. 키워드 점수가 21억에 도달하면 점수 재정렬이 일어납니다. int 의 저장범위 때문인데요  
   - 모든 키워드는 낮은 순위 키워드 순서대로 1점부터 1씩 증가되는 점수가 부여되고,  
   - UZ 점수는 10점으로 다시 초기화됩니다.  
4. 요일별 키워드뿐만 아니라 평일 / 주말 키워드도 관리됩니다.  
  이 경우, 검색 우선순위는 아래와 같습니다.  
   - 요일별 키워드 - 완벽 HIT  
   - 평일 / 주말 키워드 - 완벽 HIT  
   - 요일별 키워드 - 찰떡 HIT  
   - 평일 / 주말 키워드 - 찰떡 HIT  


**page11**  
기존 소스코드 링크입니다.  

전체 흐름을 보면서 지금까지 설명한 내용을 따라가보겠습니다.  

제시된 코드는 전체적으로 리팩토링이 필요하며, 일부 버그도 포함되어 있습니다. 이 점을 유의해서 보신다면, 오늘 평가에 도움이 되실 것으로 생각됩니다.  

```cpp
struct Node {
    string w;
    string wk;
};

struct Node2 {
    string name;
    int point;

    bool operator<(const Node2& other) const {
        return point < other.point;
    }
};
```

필요한 구조체가 명시되어 있습니다. Node2 의 경우, 정렬 기준이 되는 함수를 정의해두었는데, 구조체 벡터를 정렬하는 기준이 됩니다.  


```cpp
vector<Node2> weekBest[7]; //월 ~ 일
vector<Node2> twoBest[2]; //평일, 주말
int UZ = 9;
```

필요한 전역변수 목록입니다. `weekBest` 에선 월 - 금 이 아니라 사실 월 - 일 입니다. `twoBest` 는 주중/주말을 나타냅니다.  
벡터 각각의 요소의 사이즈 제한은 없지만, 10이 넘어갔을 때 기존 요소를 대체할지를 결정합니다.  
위 두 개의 벡터는 point 순으로 항상 정렬된 상태로 유지하겠습니다.  


`UZ` 는 기본 점수이며, 새로운 키워드가 늘어날때마다 하나씩 증가하며, 10점부터 시작합니다.
만약 21억에 도달하면 int 의 최대 값이기 때문에 점수 재정렬을 이룰 것입니다.  


먼저, `main` 함수부터 살펴보겠습니다.  

```cpp
void input() {
	ifstream fin{ "keyword_weekday_500.txt" }; //500개 데이터 입력
	for (int i = 0; i < 500; i++) {
		string t1, t2;
		fin >> t1 >> t2;
		string ret = input2(t1, t2);
		std::cout << ret << "\n";
	}
}

int main() {
	input();

}
```

파일에 저장된 500개 데이터가 입력됩니다. 파일을 열어보시면,  

```
water monday
bread tuesday
potato tuesday
light saturday
shrimp tuesday
pepper monday
music thursday
...
```
위와 같은 형태로 키워드/요일 순서로 입력되는것을 보실 수 있습니다.  

`input2` 함수는 길기 때문에 나눠서 살펴보겠습니다. 리팩토링 주요 평가사항 중 하나가, 이 함수를 분석한 후, 모듈화를 할 수 있는것인지입니다.  

```cpp
string input2(string w, string wk) {
	UZ++;

	int index = 0;
	if (wk == "monday") index = 0;
	if (wk == "tuesday") index = 1;
	if (wk == "wednesday") index = 2;
	if (wk == "thursday") index = 3;
	if (wk == "friday") index = 4;
	if (wk == "saturday") index = 5;
	if (wk == "sunday") index = 6;

	//평일 / 주말
	int index2 = 0;
	if (index >= 0 && index <= 4) index2 = 0;
	else index2 = 1;

	int point = UZ;
```
`UZ` 는 최초에 `9` 였으므로, 키워드가 입력되자마자 `10` 이 될 것입니다.  
어떤 요일인지 나타내는 `index` 변수, 그리고 주중인지 주말인지를 판단하는 `index2` 가 있습니다.  
`UZ` 를 `point` 로 받아, 완벽 / 찰떡 HIT 둘 다 아닌 경우에 주중/주말 벡터에 해당 키워드를 추가할지를 판단하는 용도로 쓸 것입니다.  

```cpp
	//관리 목록에 존재하는지 확인
	//관리되는 키워드이면 점수가 증가

	long long int max1 = 0;
	long long int max2 = 0;

	int flag = 0;
	for (Node2 &node : weekBest[index]) {
		if (node.name == w) {
			max1 = node.point + (node.point * 0.1);
			node.point += (node.point * 0.1);
			flag = 1;
			break;
		}
	}

	for (Node2 &node : twoBest[index2]) {
		if (node.name == w) {
			max2 = node.point + (node.point * 0.1);
			node.point += (node.point * 0.1);
			break;
		}
	}
```

완벽 HIT 의 경우입니다. 먼저, 월요일부터 일요일까지의 키워드를 저장하는 `weekBest` 중에서 정확하게 일치하는 검색어가 있는지 확인합니다.  
그 다음, 주중 / 주말을 의미하는 `twoBest` 중에서 완벽 HIT 가 있는지를 검사합니다.
완벽 HIT 의 경우, 기존 점수에서 10% 증가됩니다.  

```cpp
	//재정렬 작업
	if (UZ >= 2100000000 || max1 >= 2100000000 || max2 >= 2100000000) {
		UZ = 9;
		for (int i = 0; i < 5; i++) {
			int num = 1;
			for (Node2& node : weekBest[i]) {
				node.point = num;
				num++;
			}
		}	
		for (int i = 0; i < 2; i++) {
			int num = 1;
			for (Node2& node : twoBest[i]) {
				node.point = num;
				num++;
			}
		}
	}
```
`UZ` 가 21억이 넘거나, 완벽 HIT 로 인해 기존 데이터셋에서 21억이 넘는 상황이 발생할 수 있습니다.  
이 경우, `UZ` 는 다시 `9` 로 초기화하고, 기존 정렬된 데이터셋에서 가장 인기가 없는 키워드부터 `1` 부터 시작해 점수를 부여합니다.  

```cpp
	if (flag == 1) {
		return w;
	}
```

완벽 HIT 에서 정답이 발견된 경우, `flag` 가 올라가며, 해당 키워드를 반환합니다.  


```cpp
	//찰떡 HIT
	for (Node2& node : weekBest[index]) {
		if (similer(node.name, w)) {
			return node.name;
		}
	}
	
	for (Node2& node : twoBest[index]) {
		if (similer(node.name, w)) {
			return node.name;
		}
	}
```
찰떡 HIT 의 경우, 유사도 검사를 시행합니다.  

벡터가 항상 정렬된 상태로 유지되기 때문에, 점수가 높은 것부터 먼저 검사할 것입니다.  

`similar` 함수를 살펴보겠습니다.  


```cpp
// 레벤슈타인 거리 계산 알고리즘 (문자열 유사도 검사)
int levenshtein(const std::string& a, const std::string& b) {
	const size_t len_a = a.size();
	const size_t len_b = b.size();

	std::vector<std::vector<int>> d(len_a + 1, std::vector<int>(len_b + 1));

	for (size_t i = 0; i <= len_a; ++i) d[i][0] = i;
	for (size_t j = 0; j <= len_b; ++j) d[0][j] = j;

	for (size_t i = 1; i <= len_a; ++i) {
		for (size_t j = 1; j <= len_b; ++j) {
			if (a[i - 1] == b[j - 1])
				d[i][j] = d[i - 1][j - 1];
			else
				d[i][j] = 1 + std::min({ d[i - 1][j], d[i][j - 1], d[i - 1][j - 1] });
		}
	}
	return d[len_a][len_b];
}

bool similer(const std::string& a, const std::string& b) {
	if (a.empty() && b.empty()) return 100;
	if (a.empty() || b.empty()) return 1;

	int dist = levenshtein(a, b);
	int max_len = std::max(a.length(), b.length());
	// 유사도 비율 (1.0: 완전히 같음, 0.0: 전혀 다름)
	double similarity = 1.0 - (double)dist / max_len;
	
	int score = 1 + static_cast<int>(similarity * 99);
	
	if (score >= 80) return true;
	return false;
}
```

찰떡 HIT 에서 쓰이는 `similer` 함수에서는 레벤슈타인 알고리즘을 사용해 문자열 유사도를 검사합니다.  

두 개의 문자열을 받은 후, 유사도가 80% 이상인지 비교하여 boolean 리턴하는것이 핵심입니다.  

리팩토링 평가 요구사항 중 하나가, 추천 알고리즘이 변경되었을 때도 기존 코드를 유지할 수 있는지입니다. 이 부분을 신경써주시기 바랍니다.  

```cpp
	//완벽 HIT / 찰떡 HIT 둘다 아닌경우
	if (weekBest[index].size() < 10) {
		weekBest[index].push_back({ w, point });
		std::sort(weekBest[index].begin(), weekBest[index].end());
	}	
	
	if (twoBest[index].size() < 10) {
		twoBest[index].push_back({ w, point });
		std::sort(twoBest[index].begin(), twoBest[index].end());
	}

	if (weekBest[index].size() == 10) {
		if (weekBest[index].back().point < point) {
			weekBest[index].pop_back();
			weekBest[index].push_back({ w, point });
			std::sort(weekBest[index].begin(), weekBest[index].end());
		}		
	}

	if (twoBest[index].size() == 10) {
		if (twoBest[index].back().point < point) {
			twoBest[index].pop_back();
			twoBest[index].push_back({ w, point });
			std::sort(twoBest[index].begin(), twoBest[index].end());
		}		
	}

	return w;
}
```

마지막으로, 완벽 HIT / 찰떡 HIT 둘 다 아닌 경우입니다.  
이 경우, 기존 벡터의 사이즈에 따라 상황이 다릅니다.  
1. 10 개 이하일 경우, 새로운 키워드를 추가합니다.  
2. 10 개 이상일 경우, 가장 낮은 포인트의 키워드와 비교해 새로운 키워드의 포인트가 높다면, 새로운 키워드로 대체합니다.  
새로운 키워드로 갱신할 경우, point 가 정렬된채로 유지되어야 하기 때문에, sort 를 반드시 해주어야 합니다.  


**page12**  
공통과제 미션입니다. 클래스를 활용하지 않는 함수 레벨 리팩토링, 전혀 활용하지 않는 클래스 레벨로 나눠서 제시하겠습니다.


**page13**  
함수 레벨 리팩토링이며, 크게 두 가지입니다.  
1. 가독성이 좋은 코드  
   - 변수명 개선, 중복된 로직 제외, 주요 기능 함수로 분리 등의 방법으로 진행해주십시오.  
2. 안전성이 좋은 코드  
   - 안전한 문법을 사용해야 합니다.  
   - 함수 바깥에 영향을 끼치지 않는 순수 함수 사용을 권장합니다.  
 

**page14**  
클래스 레벨 리팩토링이며, 모듈화가 잘 되어있는 구조로 리팩토링할것이 요구됩니다.  
총 다섯가지 요구사항입니다.  


D1. 가독성있는 코드로 메서드 추상화, 가독성 좋은 네이밍 사용  
D2. Regression Test 를 위한 Unit Test 개발 (Mock 은 선택사항)  
D3. 확장성을 고려해 설계하는데, 유사도 검사 방식인 레벤슈타인 알고리즘이 추후 변경된다 할지라도, 기존 코드에 변경이 없도록 구현할것이 요구됩니다.  
D4. 리팩토링에 디자인 패턴을 사용합니다. 어떤 디자인 패턴을 사용할것인지는 자유입니다.  
D5. 리팩토링이 끝난 코드는 코드 커버리지 100% 를 달성해야 합니다.  


**page15**  
마지막으로, 제출 방법입니다.  
개인 리포지토리를 깃허브에 생성한 후, 다음과 같이 제출합니다.  


`mission1/` 폴더에는 메서드 레벨 리팩토링 코드를 포함합니다.  
`mission2/` 폴더에는 클래스 레벨 리팩토링 코드를 포함합니다.  


`README.md` 에는 다음 사항을 작성해주십시오.  
1. D1 ~ D5 까지 적용 여부 체크리스트  
마크다운에서 테이블 문법을 아신다면 쓰시면 되구요, 모르신다면 간단하게 적어주셔도 무방합니다.  
1. Code Coverage 최종 측정결과 캡쳐화면  
캡쳐화면은 이미지파일이기 때문에, `result.jpg` 등의 형식으로 첨부해 올리시면 됩니다.  


평가방법입니다.  
D1 ~ D5 까지 체크리스트에 체크가 된 항목은, 채점자가 수동으로 진행 수준을 평가하도록 하겠습니다.  
만약 체크가 안 된 항목은 오답처리하겠습니다.  
캡쳐 화면이 없는경우는 오답처리합니다.  


이상입니다.  
추가로, 오늘 평가 진행방법에 대해 설명드리겠습니다.  

1. 종료시간 17:30  
2. 45분 진행 15분 휴식  
3. 점심시간 11:30 ~ 12:30  
4. 전화는 강의장 밖에서  
5. 인터넷 검색 가능  
6. 휴식시간 내 강의장 밖에서만 대화 가능  


**부정행위**  
1. 평가시간동안 강의장 내에서 대화 또는 전화통화  
2. 메신저 / 사내게시판 사용  
3. GPT 등 생성형 AI 사용  
4. 사진촬영 및 평가 문제 유출  
5. 타인의 소스코드와 유사  

**퇴실**  
과제 완료되면 **휴식시간** 에 퇴실 가능  



질문 있으시다면 간단히 받고 진행하도록 하겠습니다.  